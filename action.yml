name: 'Push to Lokalise'
description: 'GitHub action to upload changed translation files in the base language from your GitHub repository to Lokalise TMS.'
author: 'Lokalise Group, Ilya Krukowski'
inputs:
  api_token:
    description: 'API token for Lokalise with read/write permissions'
    required: true
  project_id:
    description: 'Project ID for Lokalise'
    required: true
  base_lang:
    description: 'Base language (e.g., en, fr_FR)'
    required: true
    default: 'en'
  translations_path:
    description: 'Paths to translation files'
    required: true
    default: |
      locales
  file_format:
    description: 'DEPRECATED: use file_ext instead. This will be removed in the next major release. Format of the translation files (e.g., json). Find all supported file formats at https://developers.lokalise.com/reference/api-file-formats'
    default: 'json'
  file_ext:
    description: 'Custom file extension(s) to use when searching for translation files (without leading dot). Accepts either a single value (e.g. "json") or multiple newline-separated values. By default, the extension is inferred from the file_format value. However, for certain formats (e.g., json_structured), the downloaded files may still have a generic extension (e.g., .json). In such cases, this parameter allows specifying the correct extension manually to ensure proper file matching.'
    required: false
    default: 'json'
  additional_params:
    description: 'Additional parameters for Lokalise API on push. Find all supported options at https://developers.lokalise.com/reference/upload-a-file'
    required: false
    default: ''
  flat_naming:
    description: 'Use flat naming convention (true/false). If true, expects files like locales/en.json instead of locales/en/file.json'
    required: false
    default: 'false'
  name_pattern:
    description: 'Custom pattern for naming translation files. Overrides default language-based naming. Must include both filename and extension if applicable (e.g., "custom_name.json" or "**/*.yaml"). Default behavior is used if not set.'
    required: false
    default: ''
  skip_tagging:
    description: 'Do not assign tags to the uploaded translation keys on Lokalise'
    required: false
    default: 'false'
  skip_polling:
    description: 'Do not wait for the upload operation to be marked as completed on Lokalise'
    required: false
    default: 'false'
  skip_default_flags:
    description: 'Do not set any extra flags for the upload command'
    required: false
    default: 'false'
  rambo_mode:
    description: 'Always upload all translation files for the base language regardless of changes'
    required: false
    default: 'false'
  max_retries:
    description: 'Maximum number of retries on rate limit errors'
    required: false
    default: '3'
  sleep_on_retry:
    description: 'Number of seconds to sleep before retrying'
    required: false
    default: '1'
  http_timeout:
    description: 'Timeout for HTTP calls (in seconds)'
    required: false
    default: '120'
  upload_timeout:
    description: 'Timeout for the whole upload operation (in seconds)'
    required: false
    default: '600'
  poll_initial_wait:
    description: 'Number of seconds to wait before polling the upload process for the first time'
    required: false
    default: '1'
  poll_max_wait:
    description: 'Timeout for polling the upload process'
    required: false
    default: '120'
  os_platform:
    description: 'Target platform for the binary (linux_amd64, linux_arm64, mac_amd64, mac_arm64)'
    required: false
    default: 'linux_amd64'
  git_user_name:
    description: 'Optional Git username to use when tagging the initial Lokalise upload. Defaults to GitHub actor.'
    required: false
    default: ''
  git_user_email:
    description: 'Optional Git email to use when tagging the initial Lokalise upload. Defaults to "<username>@users.noreply.github.com".'
    required: false
    default: ''
  use_tag_tracking:
    description: 'Use git tags to track last synced commit per branch'
    required: false
    default: 'false'

branding:
  icon: 'upload-cloud'
  color: 'green'
outputs:
  initial_run:
    description: 'A boolean value indicating whether this is the initial run on the branch.'
    value: ${{ steps.check-first-run.outputs.first_run }}
  files_uploaded:
    description: 'A boolean value indicating whether any files were uploaded to Lokalise.'
    value: ${{ steps.check-files-upload.outputs.files_uploaded }}

runs:
  using: "composite"
  steps:
    - name: Set translation paths
      id: translation-paths
      shell: bash
      env:
        TRANSLATIONS_PATH: "${{ inputs.translations_path }}"
        FLAT_NAMING: "${{ inputs.flat_naming }}"
        BASE_LANG: "${{ inputs.base_lang }}"
        FILE_FORMAT: "${{ inputs.file_format }}"
        FILE_EXT: "${{ inputs.file_ext }}"
        NAME_PATTERN: "${{ inputs.name_pattern }}"
        PLATFORM: "${{ inputs.os_platform }}"
      run: |
        set -euo pipefail

        echo "Setting translation paths..."

        CMD_PATH="${{ github.action_path }}/bin/store_translation_paths_${PLATFORM}"
        if [ ! -f "$CMD_PATH" ]; then
          echo "Error: Binary for platform '${PLATFORM}' not found!"
          exit 1
        fi
        chmod +x "$CMD_PATH" || true
        "$CMD_PATH" || {
          echo "Error: store_translation_paths script failed with exit code $?"
          exit 1
        }

        echo "Translations paths have been set!"

    - name: Get last sync tag SHA
      if: inputs.rambo_mode != 'true' && inputs.use_tag_tracking == 'true'
      id: get-last-sync-sha
      shell: bash
      run: |
        set -euo pipefail

        BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
        TAG_NAME="lokalise-sync-${BRANCH_NAME}"
        echo "Looking for tag: $TAG_NAME"

        if git ls-remote --exit-code --refs --tags origin "refs/tags/$TAG_NAME" >/dev/null 2>&1; then
          echo "Tag '$TAG_NAME' found on remote."
          
          git fetch --quiet origin "refs/tags/$TAG_NAME:refs/tags/$TAG_NAME" || true
          TAG_SHA=$(git rev-list -n1 "$TAG_NAME" 2>/dev/null || echo "")
          if [ -n "$TAG_SHA" ]; then
            echo "Found tag '$TAG_NAME': $TAG_SHA"
            echo "base_sha=$TAG_SHA" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "Warning: tag exists on remote but could not resolve SHA locally."
        else
          echo "Tag '$TAG_NAME' not found on remote."
        fi

        echo "Falling back to HEAD~1..."
        if git rev-parse HEAD~1 >/dev/null 2>&1; then
          FALLBACK_SHA=$(git rev-parse HEAD~1)
          echo "Fallback SHA resolved: $FALLBACK_SHA"
          echo "base_sha=$FALLBACK_SHA" >> "$GITHUB_OUTPUT"
        else
          ROOT_SHA=$(git rev-parse HEAD)
          echo "Only one commit in history. Using HEAD: $ROOT_SHA"
          echo "base_sha=$ROOT_SHA" >> "$GITHUB_OUTPUT"
        fi

    - name: Skip if no new commits since last sync
      if: inputs.rambo_mode != 'true' && inputs.use_tag_tracking == 'true'
      id: check-sha
      shell: bash
      run: |
        set -euo pipefail

        BASE_SHA="${{ steps.get-last-sync-sha.outputs.base_sha }}"
        CUR_SHA="${{ github.sha }}"

        echo "base_sha: $BASE_SHA"
        echo "current_sha: $CUR_SHA"

        if [[ -n "$BASE_SHA" && "$BASE_SHA" == "$CUR_SHA" ]]; then
          echo "No new commits since last sync – skipping diff."
          echo "identical=true" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "Commits differ (or base_sha empty) – continue."
        echo "identical=false" >> "$GITHUB_OUTPUT"

    - name: Get changed files
      if: inputs.rambo_mode != 'true' && (inputs.use_tag_tracking != 'true' || steps.check-sha.outputs.identical != 'true')
      id: changed-files
      # tj-actions/changed-files@v47.0.0
      uses: tj-actions/changed-files@abdd2f68ea150cee8f236d4a9fb4e0f2491abf1b
      with:
        files_from_source_file: lok_action_paths_temp.txt
        separator: ','
        base_sha: ${{ inputs.use_tag_tracking == 'true' && steps.get-last-sync-sha.outputs.base_sha || '' }}
        sha: ${{ inputs.use_tag_tracking == 'true' && github.sha || '' }}

    - name: Check if this is the first run on the branch
      id: check-first-run
      shell: bash
      run: |
        set -euo pipefail

        TAG_NAME="lokalise-upload-complete"
        echo "Checking if this is the first action run... (tag: $TAG_NAME)"

        if git ls-remote --exit-code --refs --tags origin "refs/tags/$TAG_NAME" >/dev/null 2>&1; then
          echo "This is not the first action run."
          echo "first_run=false" >> "$GITHUB_OUTPUT"
        else
          echo "This is the first action run."
          echo "first_run=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Find all translation files
      if: |
        inputs.rambo_mode == 'true' ||
        (
          inputs.use_tag_tracking == 'true' &&
          steps.check-first-run.outputs.first_run == 'true' &&
          (
            steps.check-sha.outputs.identical == 'true' ||
            steps.changed-files.outputs.any_changed == 'false'
          )
        ) ||
        (
          inputs.use_tag_tracking != 'true' &&
          steps.changed-files.outputs.any_changed != 'true' &&
          steps.check-first-run.outputs.first_run == 'true'
        )
      id: find-files
      shell: bash
      env:
        TRANSLATIONS_PATH: "${{ inputs.translations_path }}"
        BASE_LANG: "${{ inputs.base_lang }}"
        FILE_FORMAT: "${{ inputs.file_format }}"
        FILE_EXT: "${{ inputs.file_ext }}"
        FLAT_NAMING: "${{ inputs.flat_naming }}"
        NAME_PATTERN: "${{ inputs.name_pattern }}"
        PLATFORM: "${{ inputs.os_platform }}"
      run: |
        set -euo pipefail

        echo "Collecting all translation files..."

        if [ "${{ inputs.rambo_mode }}" == "true" ]; then
          echo "Rambo mode is enabled: uploading all files regardless of changes."

        elif [ "${{ inputs.use_tag_tracking }}" == "true" ] && \
            [ "${{ steps.check-first-run.outputs.first_run }}" == "true" ] && \
            { [ "${{ steps.check-sha.outputs.identical }}" == "true" ] || [ "${{ steps.changed-files.outputs.any_changed }}" == "false" ]; }; then
          echo "Either no new commits or no file changes detected, and it's the first action run: uploading all files."

        elif [ "${{ inputs.use_tag_tracking }}" != "true" ] && \
            [ "${{ steps.changed-files.outputs.any_changed }}" == "false" ] && \
            [ "${{ steps.check-first-run.outputs.first_run }}" == "true" ]; then
          echo "No file changes detected, and it's the first action run: uploading all files."

        else
          echo "Not sure how we got here, but collecting all files anyway. This is probably unexpected, check your workflow."
        fi

        CMD_PATH="${{ github.action_path }}/bin/find_all_files_${PLATFORM}"
        if [ ! -f "$CMD_PATH" ]; then
          echo "Error: Binary for platform '${PLATFORM}' not found!"
          exit 1
        fi
        chmod +x "$CMD_PATH" || true
        "$CMD_PATH" || {
          echo "Error: find_all_files script failed with exit code $?"
          exit 1
        }

        echo "All files collected!"

    - name: Push translation files to Lokalise
      if: steps.find-files.outputs.has_files == 'true' || steps.changed-files.outputs.any_changed == 'true'
      id: push-translation-files
      shell: bash
      env:
        LOKALISE_PROJECT_ID: "${{ inputs.project_id }}"
        LOKALISE_API_TOKEN: "${{ inputs.api_token }}"
        BASE_LANG: "${{ inputs.base_lang }}"
        ADDITIONAL_PARAMS: "${{ inputs.additional_params }}"
        MAX_RETRIES: "${{ inputs.max_retries }}"
        SLEEP_TIME: "${{ inputs.sleep_on_retry }}"
        UPLOAD_TIMEOUT: "${{ inputs.upload_timeout }}"
        HTTP_TIMEOUT: "${{ inputs.http_timeout }}"
        SKIP_TAGGING: "${{ inputs.skip_tagging }}"
        SKIP_POLLING: "${{ inputs.skip_polling }}"
        POLL_INITIAL_WAIT: "${{ inputs.poll_initial_wait }}"
        POLL_MAX_WAIT: "${{ inputs.poll_max_wait }}"
        SKIP_DEFAULT_FLAGS: "${{ inputs.skip_default_flags }}"
        PLATFORM: "${{ inputs.os_platform }}"
      run: |
        set -euo pipefail

        echo "Pushing files to Lokalise..."

        if [ "${{ inputs.rambo_mode }}" == "true" ] || \
          ( [ "${{ steps.changed-files.outputs.any_changed }}" != "true" ] && [ "${{ steps.check-first-run.outputs.first_run }}" == "true" ] ); then
          FILES="${{ steps.find-files.outputs.ALL_FILES }}"
        else
          FILES="${{ steps.changed-files.outputs.all_changed_files }}"
        fi

        if [ -z "$FILES" ]; then
          echo "No files to upload."
          exit 0
        fi

        CMD_PATH="${{ github.action_path }}/bin/lokalise_upload_${PLATFORM}"
        if [ ! -f "$CMD_PATH" ]; then
          echo "Error: Binary for platform '${PLATFORM}' not found!"
          exit 1
        fi
        chmod +x "$CMD_PATH" || true

        set +e
        printf '%s' "$FILES" | tr ',' '\n' | xargs -P 6 -I{} -- "$CMD_PATH" "{}"
        xargs_exit_code=$?
        set -euo pipefail

        if [ $xargs_exit_code -ne 0 ]; then
          echo "File upload failed"
          exit 1
        fi

        echo "All translation files have been pushed!"

        echo "files_uploaded=true" >> "$GITHUB_OUTPUT"

    - name: Mark Lokalise upload complete and update sync tag (if needed)
      if: steps.push-translation-files.outputs.files_uploaded == 'true' && (steps.check-first-run.outputs.first_run == 'true' || inputs.use_tag_tracking == 'true')
      shell: bash
      env:
        USE_TAG_TRACKING: "${{ inputs.use_tag_tracking }}"
        FIRST_RUN: "${{ steps.check-first-run.outputs.first_run }}"
        GIT_USER_NAME: "${{ inputs.git_user_name }}"
        GIT_USER_EMAIL: "${{ inputs.git_user_email }}"
      run: |
        set -euo pipefail

        echo "Lokalise tagging..."

        # Git identity (fallback to actor)
        USER_NAME="${GIT_USER_NAME:-$GITHUB_ACTOR}"
        USER_EMAIL="${GIT_USER_EMAIL:-${USER_NAME}@users.noreply.github.com}"
        git config --global user.name "$USER_NAME"
        git config --global user.email "$USER_EMAIL"

        # Resolve a real branch name even on pull_request events
        BRANCH_NAME="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
        TAG_SYNC_NAME="lokalise-sync-${BRANCH_NAME}"

        # ---- Part 1: Global 'first run' tag ----
        if [[ "$FIRST_RUN" == "true" ]]; then
          GLOBAL_TAG="lokalise-upload-complete"
          echo "Marking first run with global tag '$GLOBAL_TAG'..."

          # Create locally only if missing
          if ! git rev-parse -q --verify "refs/tags/$GLOBAL_TAG" >/dev/null; then
            MSG="Initial Lokalise upload completed, run=$GITHUB_RUN_ID, sha=$GITHUB_SHA, $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
            git tag -a "$GLOBAL_TAG" -m "$MSG"
          fi

          # Push; handle race (another job might create it between our checks)
          if git push origin "refs/tags/$GLOBAL_TAG"; then
            echo "Created global tag '$GLOBAL_TAG'."
          else
            echo "Push of '$GLOBAL_TAG' failed. Checking remote (race?)"
            if git ls-remote --exit-code --refs --tags origin "refs/tags/$GLOBAL_TAG" >/dev/null 2>&1; then
              echo "Global tag already exists; proceeding."
            else
              echo "Failed to create global tag '$GLOBAL_TAG' and it doesn't exist remotely."
              exit 1
            fi
          fi
        fi

        # ---- Part 2: Branch-scoped moving sync tag ----
        if [[ "$USE_TAG_TRACKING" == "true" ]]; then
          SHORT=$(git rev-parse --short HEAD)
          MSG="Lokalise sync completed on '$BRANCH_NAME', run=$GITHUB_RUN_ID, sha=$GITHUB_SHA, $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          echo "Updating branch sync tag '$TAG_SYNC_NAME' -> $SHORT"
          git tag -fa "$TAG_SYNC_NAME" -m "$MSG"
          git push --force origin "refs/tags/$TAG_SYNC_NAME"
          echo "Tag '$TAG_SYNC_NAME' now points to $SHORT."
        fi

        echo "Tagging step completed."

    - name: Verify file upload success
      id: check-files-upload
      shell: bash
      run: |
        echo "Verifying upload success..."

        if [ "${{ steps.push-translation-files.outputs.files_uploaded }}" != "true" ]; then
          echo "Nothing has been uploaded."
          echo "files_uploaded=false" >> "$GITHUB_OUTPUT"
        else
          echo "Files have been uploaded."
          echo "files_uploaded=true" >> "$GITHUB_OUTPUT"
        fi